## ams_version=1.0

Model Main_EVChargingLocations {
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: minute->s : #-># * 60;
				Comment: {
					"Expresses the value for the duration of periods.
					
					The unit s has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI."
				}
			}
		}
		DeclarationSection Master_Data {
			Set s_def_particles {
				Text: "Set of particles in each individual.";
				Index: i_particle;
				Definition: {
					ElementRange(
						From    :  1, 
						To      :  p_numberParticles, 
						Prefix  :  "p")
				}
			}
			Set s_def_generations {
				Text: "Number of generations the algorithm runs for.";
				Index: i_gen;
				Definition: {
					ElementRange(
						From    :  1, 
						To      :  p_numberGenerations, 
						Prefix  :  "g")
				}
			}
			Set s_def_individuals {
				Text: "Set of inidivuals in the population.";
				Index: i_indv;
				Parameter: ep_individual;
				Definition: {
					ElementRange(
						From    :  1, 
						To      :  p_populationSize, 
						Prefix  :  "i")
				}
			}
			Set s_locations {
				Text: "Set of locations.";
				Index: i_loc1;
			}
			Index i_loc {
				Range: s_locations;
				dex::ColumnName: Location;
			}
			Parameter p_longitude {
				IndexDomain: i_loc;
				dex::ColumnName: Longitude;
				dex::Dataset: DefaultData;
				dex::TableName: Locations;
			}
			Parameter p_latitude {
				IndexDomain: i_loc;
				dex::ColumnName: Latitude;
				dex::Dataset: DefaultData;
				dex::TableName: Locations;
			}
		}
		DeclarationSection Control_Panel {
			Parameter p_maintenanceCost {
				InitialData: 500;
			}
			Parameter p_constructionCost {
				InitialData: 5000;
			}
			Parameter p_drivingCostPerMile {
				InitialData: 0.2;
			}
			Parameter p_chargingCostPerHour {
				InitialData: 0.5;
			}
			Parameter p_noAllocationPenalty {
				InitialData: 5000;
			}
			Parameter p_maxNumberVehiclesPerStation {
				InitialData: 16;
			}
			Parameter p_numberParticles {
				Text: "The number of particles in each individual.";
				Range: integer;
				InitialData: 600;
			}
			Parameter p_numberGenerations {
				InitialData: 10;
			}
			Parameter p_populationSize {
				Text: "Number of individuals in the population.";
				Range: integer;
				InitialData: 5;
			}
			Parameter p_inertiaComponent {
				InitialData: 0.3;
			}
			Parameter p_cognitiveComponent {
				InitialData: 0.2;
			}
			Parameter p_socialComponent {
				InitialData: 0.2;
			}
		}
	}
	Section Initiate_Procedures {
		Comment: "This section contains procedures that are necessary to initiate the PSO algorithm, such as spawning initial locations with initial velocities.";
		DeclarationSection Spawning_Declaration {
			Parameter XY_spawn_region {
				Text: "Region in which particles each particle is spawned in an individual.";
				Definition: 10;
			}
			Parameter XY_initial_velocity {
				Definition: 5;
			}
			Parameter p_initialParticleLocationsX {
				IndexDomain: i_particle;
				Text: "Region in which to spawn each particle for each individual.";
			}
			Parameter p_initialParticleLocationsY {
				IndexDomain: i_particle;
				Text: "Region in which to spawn each particle for each individual.";
			}
			Parameter X_min {
				Text: "Lowerbound for x-domain.";
				Definition: 0;
			}
			Parameter X_max {
				Text: "Upperbound for x-domain.";
				Definition: max(i_loc, p_longitude(i_loc));
			}
			Parameter Y_min {
				Text: "Lowerbound for y-domain.";
				Definition: 0;
			}
			Parameter Y_max {
				Text: "Upperbound for y-domain.";
				Definition: max(i_loc, p_latitude(i_loc));
			}
		}
	}
	Section PSO_Model {
		Comment: "This section contains procedures that align with the main operations within PSO.";
		DeclarationSection Solution_Declaration {
			Parameter p_currentSolutionX {
				IndexDomain: (i_indv,i_particle);
				Text: "X coordinates of the current solution for the individual.";
			}
			Parameter p_previousSolutionX {
				IndexDomain: (i_indv,i_particle);
				Text: "X coordinates of the previous solution for the individual.";
			}
			Parameter p_currentSolutionY {
				IndexDomain: (i_indv,i_particle);
				Text: "Y coordinates of the current solution for the individual.";
			}
			Parameter p_previousSolutionY {
				IndexDomain: (i_indv,i_particle);
				Text: "Y coordinates of the previous solution for the individual.";
			}
		}
		DeclarationSection Solution_Velocity_Declaration {
			Parameter p_currentSolutionVelocityX {
				IndexDomain: (i_indv,i_particle);
				Text: "X velocity of the current solution for the individual.";
			}
			Parameter p_previousSolutionVelocityX {
				IndexDomain: (i_indv,i_particle);
				Text: "X velocity of the previous solution for the individual.";
			}
			Parameter p_currentSolutionVelocityY {
				IndexDomain: (i_indv,i_particle);
				Text: "Y velocity of the current solution for the individual.";
			}
			Parameter p_previousSolutionVelocityY {
				IndexDomain: (i_indv,i_particle);
				Text: "Y velocity of the previous solution for the individual.";
			}
		}
		DeclarationSection Best_Global_Solution_Declaration {
			Parameter p_bestGlobalSolution_Cost {
				Default: 999999999;
			}
			Parameter p_bestGlobalSolutionX {
				IndexDomain: (i_particle);
				Text: "Best global solution X coordinate.";
			}
			Parameter p_bestGlobalSolutionY {
				IndexDomain: (i_particle);
				Text: "Best global solution Y coordinate.";
			}
		}
		DeclarationSection Best_Local_Solution_Declaration {
			Parameter p_bestLocalSolution_Cost {
				IndexDomain: (i_indv);
				Default: inf;
			}
			Parameter p_bestLocalSolutionX {
				IndexDomain: (i_indv,i_particle);
				Text: "Best local solution X coordinate.";
			}
			Parameter p_bestLocalSolutionY {
				IndexDomain: (i_indv,i_particle);
				Text: "Best local solution Y coordinate.";
			}
		}
		Procedure Variation_Procedures {
			Body: {
				! Apply the velocity update
				Update_Velocity;
				
				! Apply the position update
				Update_Position;
				
				! Find the global and local bests
				Get_Global_Best;
				Get_Local_Best;
			}
		}
		Procedure Update_Velocity {
			Body: {
				p_previousSolutionVelocityX(i_indv,i_particle) := p_currentSolutionVelocityX(i_indv,i_particle);
				p_previousSolutionVelocityY(i_indv,i_particle) := p_currentSolutionVelocityY(i_indv,i_particle);
				
				InertiaX(i_indv,i_particle) := p_inertiaComponent * p_previousSolutionVelocityX(i_indv,i_particle);
				InertiaY(i_indv,i_particle) := p_inertiaComponent * p_previousSolutionVelocityY(i_indv,i_particle);
				
				CognitiveX(i_indv,i_particle) := p_cognitiveComponent * (p_bestLocalSolutionX(i_indv,i_particle) - p_currentSolutionX(i_indv,i_particle));
				CognitiveY(i_indv,i_particle) := p_cognitiveComponent * (p_bestLocalSolutionY(i_indv,i_particle) - p_currentSolutionY(i_indv,i_particle));
				
				SocialX(i_indv,i_particle) := p_socialComponent * (p_bestGlobalSolutionX(i_particle) - p_currentSolutionX(i_indv,i_particle));
				SocialY(i_indv,i_particle) := p_socialComponent * (p_bestGlobalSolutionY(i_particle) - p_currentSolutionY(i_indv,i_particle));
				
				p_currentSolutionVelocityX(i_indv,i_particle) := InertiaX(i_indv,i_particle) + CognitiveX(i_indv,i_particle) + SocialX(i_indv,i_particle);
				p_currentSolutionVelocityY(i_indv,i_particle) := InertiaY(i_indv,i_particle) + CognitiveY(i_indv,i_particle) + SocialY(i_indv,i_particle);
			}
			Parameter InertiaX {
				IndexDomain: (i_indv,i_particle);
			}
			Parameter InertiaY {
				IndexDomain: (i_indv,i_particle);
			}
			Parameter CognitiveX {
				IndexDomain: (i_indv,i_particle);
			}
			Parameter CognitiveY {
				IndexDomain: (i_indv,i_particle);
			}
			Parameter SocialX {
				IndexDomain: (i_indv,i_particle);
			}
			Parameter SocialY {
				IndexDomain: (i_indv,i_particle);
			}
		}
		Procedure Update_Position {
			Body: {
				p_previousSolutionX(i_indv,i_particle) := p_currentSolutionX(i_indv,i_particle);
				p_previousSolutionY(i_indv,i_particle) := p_currentSolutionY(i_indv,i_particle);
				
				p_currentSolutionX(i_indv,i_particle) := p_previousSolutionX(i_indv,i_particle) + p_currentSolutionVelocityX(i_indv,i_particle);
				p_currentSolutionY(i_indv,i_particle) := p_previousSolutionY(i_indv,i_particle) + p_currentSolutionVelocityY(i_indv,i_particle);
			}
		}
		Procedure Get_Global_Best {
			Body: {
				global_best := ArgMin[i_indv, TotalObjectiveCost(i_indv)];
				
				if TotalObjectiveCost(global_best) < p_bestGlobalSolution_Cost then
				
					p_bestGlobalSolution_Cost := TotalObjectiveCost(global_best);
				
					p_bestGlobalSolutionX(i_particle) := p_currentSolutionX(global_best,i_particle);
					p_bestGlobalSolutionY(i_particle) := p_currentSolutionY(global_best,i_particle);
				
				endif;
			}
			ElementParameter global_best {
				Range: s_def_individuals;
			}
		}
		Procedure Get_Local_Best {
			Body: {
				for (i_indv in s_def_individuals) do
				
					if TotalObjectiveCost(i_indv) < p_bestLocalSolution_Cost(i_indv) then
				
						p_bestLocalSolution_Cost(i_indv) := TotalObjectiveCost(i_indv);
				
						p_bestLocalSolutionX(i_indv,i_particle) := p_currentSolutionX(i_indv,i_particle);
						p_bestLocalSolutionY(i_indv,i_particle) := p_currentSolutionY(i_indv,i_particle);
				
					endif;
				
				endfor;
			}
		}
	}
	Section Assignment_Model {
		Comment: "This section is focused on the assignment aspect of the algorithm. Assigning vehicles to stations. A MIP is included, however, the heuristic (KNN) is preferred.";
		DeclarationSection MIP_Declaration {
			Parameter Distances_domain {
				IndexDomain: (i_particle,i_loc,i_indv);
				Definition: Distances(i_particle,i_loc,i_indv) <= 30;
			}
			Variable Vehicle_to_Station {
				IndexDomain: (i_particle,i_loc,i_indv);
				Range: binary;
			}
			Variable Max_Vehicles_Violation {
				IndexDomain: (i_loc,i_indv);
				Range: nonnegative;
			}
			Constraint Assign_Vehicle_to_Station {
				IndexDomain: (i_particle,i_indv) | exists[i_loc, Distances_domain(i_particle,i_loc,i_indv)];
				Definition: sum[ i_loc, Vehicle_to_Station(i_particle,i_loc,i_indv)] = 1;
			}
			Constraint Restrict_Max_Vehicles {
				IndexDomain: (i_loc,i_indv);
				Definition: sum[ i_particle, Vehicle_to_Station(i_particle,i_loc,i_indv)] <= 16 + Max_Vehicles_Violation(i_loc,i_indv);
			}
			Variable TotalDistance {
				Range: free;
				Definition: sum[ (i_particle,i_loc,i_indv) | Distances_domain(i_particle,i_loc,i_indv), Vehicle_to_Station(i_particle,i_loc,i_indv) * Distances(i_particle,i_loc,i_indv)];
			}
			Variable TotalPenalty {
				Range: free;
				Definition: sum[ (i_loc,i_indv), Max_Vehicles_Violation(i_loc,i_indv)] * 1000;
			}
			Variable TotalCost {
				Range: free;
				Definition: {
					TotalDistance
					+ TotalPenalty
				}
			}
			MathematicalProgram MIP_Assignment {
				Objective: TotalCost;
				Direction: minimize;
				Constraints: AllConstraints;
				Variables: AllVariables;
				Type: Automatic;
			}
		}
		DeclarationSection KNN_Declaration {
			Parameter N_Closest {
				Range: integer;
				Definition: 20;
			}
			Parameter Distance_Cutoff {
				Definition: 50;
			}
			Parameter Distances {
				IndexDomain: (i_particle,i_loc,i_indv);
			}
			Parameter p_distances_prev {
				IndexDomain: (i_particle,i_loc,i_indv);
			}
			Set n_closest_set {
				SubsetOf: Integers;
				Index: n_clos;
				Definition: ElementRange(1, N_Closest, 1);
			}
			ElementParameter N_Closest_Locations {
				IndexDomain: (i_loc,i_indv);
				Range: s_def_particles;
			}
			Parameter Unallocated_Locations {
				IndexDomain: (i_loc,i_indv);
				Definition: {
					if not N_Closest_Locations(i_loc,i_indv) then
						1
					else
						0
					endif;
				}
			}
			Parameter Allocation_Count {
				IndexDomain: (i_particle,i_indv);
			}
			Parameter Active_Station {
				IndexDomain: (i_particle,i_indv);
				Definition: {
					if Allocation_Count(i_particle,i_indv) then
						1
					else
						0
					endif;
				}
			}
		}
		DeclarationSection Cost_Declaration {
			Parameter TotalConstructionCost {
				IndexDomain: i_indv;
			}
			Parameter TotalMaintenanceCost {
				IndexDomain: i_indv;
			}
			Parameter DrivingCost {
				IndexDomain: (i_loc,i_indv);
				Definition: p_drivingCostPerMile * Distances(N_Closest_Locations(i_loc,i_indv),i_loc,i_indv);
			}
			Parameter ChargingCost {
				IndexDomain: (i_loc,i_indv);
				Definition: p_chargingCostPerHour;
			}
			Parameter TotalDrivingCost {
				IndexDomain: (i_indv);
			}
			Parameter TotalChargingCost {
				IndexDomain: (i_indv);
			}
			Parameter TotalPenaltyCost {
				IndexDomain: i_indv;
			}
			Parameter TotalObjectiveCost {
				IndexDomain: i_indv;
			}
		}
		Procedure KNN_Subroutine {
			Body: {
				Calculate_Distances;
				
				Get_Closest;
			}
		}
		Procedure Calculate_Distances {
			Body: {
				for (i_indv in s_def_individuals) do
				
					! Calculate the Euclidean distance between each particle and each location
					Distances(i_particle,i_loc,i_indv) := sqrt[(p_currentSolutionX(i_indv,i_particle) - p_longitude(i_loc))^2 + (p_currentSolutionY(i_indv,i_particle) - p_latitude(i_loc))^2];
				
				endfor;
			}
		}
		Procedure Get_Closest {
			Body: {
				Distances_temp(i_particle,i_loc,i_indv) := Distances(i_particle,i_loc,i_indv) $ (Distances(i_particle,i_loc,i_indv) < Distance_Cutoff);
				
				empty Allocation_Count;
				empty N_Closest_Locations;
				
				for (i_indv in s_def_individuals) do
				
					for (i_loc in s_locations) do
				
						empty local_temp;
						local_break := 0;
				
						! Find the nearest N locations
						for n_clos in {1 .. N_Closest} do
				
							! Now, if we manage an allocation then stop looking for the next N closest
							local_temp(i_loc,n_clos,i_indv) := ArgMin(i_particle | Distances_temp(i_particle,i_loc,i_indv) and (0.1 * Allocation_Count(i_particle,i_indv) < p_maxNumberVehiclesPerStation), Distances_temp(i_particle,i_loc,i_indv));
							N_Closest_Locations(i_loc,i_indv) := local_temp(i_loc,n_clos,i_indv);
							Allocation_Count(local_temp(i_loc,n_clos,i_indv),i_indv) += 1;
							Distances_temp(local_temp(i_loc,n_clos,i_indv),i_loc,i_indv) := 0;
				
							if local_temp(i_loc,n_clos,i_indv) then
								local_break := 1;
								break;
							endif;
				
						endfor;
					endfor;
				endfor;
			}
			Comment: "Determine the N closest locations for each vehicle";
			Parameter local_break {
				Default: 0;
			}
			Parameter Distances_temp {
				IndexDomain: (i_particle,i_loc,i_indv);
			}
			ElementParameter local_temp {
				IndexDomain: (i_loc,n_clos,i_indv);
				Range: s_def_particles;
			}
		}
		Procedure Evaluate_Cost {
			Body: {
				TotalConstructionCost(i_indv) := p_constructionCost * sum( i_particle, Active_Station(i_particle,i_indv));
				TotalMaintenanceCost(i_indv) := p_maintenanceCost * sum( i_particle, Active_Station(i_particle,i_indv));
				TotalDrivingCost(i_indv) := sum[ i_loc, DrivingCost(i_loc,i_indv)];
				TotalChargingCost(i_indv) := sum[ i_loc, ChargingCost(i_loc,i_indv)];
				TotalPenaltyCost(i_indv) := p_noAllocationPenalty * sum[ i_loc, Unallocated_Locations(i_loc,i_indv)];
				
				TotalObjectiveCost(i_indv) := 	TotalDrivingCost(i_indv)
											+ TotalChargingCost(i_indv)
											+ TotalConstructionCost(i_indv)
											+ TotalMaintenanceCost(i_indv)
											+ TotalPenaltyCost(i_indv);
			}
		}
		Procedure Solve_MIP {
			Body: {
				solve MIP_Assignment;
			}
		}
	}
	Section Results_Section {
		Comment: "Section to record and wrangle different results for display on the UI.";
		Section Generational_Results {
			DeclarationSection Fitness {
				Parameter GenerationalFitness {
					IndexDomain: i_gen;
				}
				Parameter GlobalBestFitness {
					IndexDomain: i_gen;
				}
			}
		}
		DeclarationSection MIP_Assignments {
			Parameter Vehicle_to_Station_Distances {
				IndexDomain: (i_particle,i_loc,i_indv);
				Definition: Vehicle_to_Station(i_particle,i_loc,i_indv) * Distances(i_particle,i_loc,i_indv);
			}
		}
	}
	Procedure pr_initializeProblem {
		Body: {
			block ! Spawn Individuals 
			! Starting locations for the particles
			p_initialParticleLocationsX(i_particle) := Uniform(X_min, X_max);
			p_initialParticleLocationsY(i_particle) := Uniform(Y_min, Y_max);
			
			! Starting locations for the particles in each individual
			p_currentSolutionX(i_indv, i_particle) 
			:=  p_initialParticleLocationsX(i_particle) 
			    + Uniform(-XY_spawn_region, XY_spawn_region);
			
			p_currentSolutionY(i_indv, i_particle) 
			:=  p_initialParticleLocationsY(i_particle) 
			    + Uniform(-XY_spawn_region, XY_spawn_region);
			
			! Starting velocities
			p_currentSolutionVelocityX(i_indv, i_particle) := Normal(0, 5);
			p_currentSolutionVelocityY(i_indv, i_particle) := Normal(0, 5);
			endblock;
			
			block ! Initiate Cognitive Component 
			! Set the best local solution as something close to the initial solution
			p_bestLocalSolutionX(i_indv,i_particle) := p_currentSolutionX(i_indv,i_particle) + uniform(-XY_spawn_region/2, XY_spawn_region/2);
			p_bestLocalSolutionY(i_indv,i_particle) := p_currentSolutionY(i_indv,i_particle) + uniform(-XY_spawn_region/2, XY_spawn_region/2);
			endblock;
			
			block ! Initiate Social Component 
			! Select random individual as the initial best global
			ep_individual := StringToElement(s_def_individuals, round(uniform(0, p_populationSize)));
			
			! Set the best local solution as something close to the initial solution
			p_bestGlobalSolutionX(i_particle) := p_currentSolutionX(ep_individual, i_particle);
			p_bestGlobalSolutionY(i_particle) := p_currentSolutionY(ep_individual, i_particle);
			endblock;
			
			p_distances_prev(i_particle,i_loc,i_indv) := 500;
			
			p_bestLocalSolution_Cost(i_indv) := inf;
			p_bestGlobalSolution_Cost := inf;
		}
	}
	Procedure RunPSOAlgorithm {
		Body: {
			pr_initializeProblem;
			
			for (i_gen in s_def_generations) do
			
				KNN_Subroutine;
				Evaluate_Cost;
				Variation_Procedures;
			
				GenerationalFitness(i_gen) := mean[ i_indv, TotalObjectiveCost(i_indv)];
				GlobalBestFitness(i_gen) := p_bestGlobalSolution_Cost;
			
			endfor;
		}
	}
	Procedure ResetPSO {
		Body: {
			empty Allocation_Count;
			
			empty Solution_Declaration, Solution_Velocity_Declaration, Best_Global_Solution_Declaration, Best_Local_Solution_Declaration;
		}
	}
	Procedure MainInitialization {
		Comment: "Add initialization statements here that do NOT require any library being initialized already.";
	}
	Procedure PostMainInitialization {
		Comment: {
			"Add initialization statements here that require that the libraries are already initialized properly,
			or add statements that require the Data Management module to be initialized."
		}
	}
	Procedure MainExecution;
	Procedure PreMainTermination {
		Body: {
			return DataManagementExit();
		}
		Comment: {
			"Add termination statements here that require all libraries to be still alive.
			Return 1 if you allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence."
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require all libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
}
