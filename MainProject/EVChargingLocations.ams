## ams_version=1.0

Model Main_EVChargingLocations {
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: minute->s : #-># * 60;
				Comment: {
					"Expresses the value for the duration of periods.
					
					The unit s has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI."
				}
			}
		}
		DeclarationSection Master_Data {
			Set s_def_particles {
				Text: "Set of particles in each individual.";
				Index: i_particle;
				Definition: {
					ElementRange(
						From    :  1, 
						To      :  p_numberParticles, 
						Prefix  :  "p")
				}
			}
			Set s_def_generations {
				Text: "Number of generations the algorithm runs for.";
				Index: i_gen;
				Definition: {
					ElementRange(
						From    :  1, 
						To      :  p_numberGenerations, 
						Prefix  :  "g")
				}
			}
			Set s_def_individuals {
				Text: "Set of inidivuals in the population.";
				Index: i_indv;
				Parameter: ep_individual;
				Definition: {
					ElementRange(
						From    :  1, 
						To      :  p_populationSize, 
						Prefix  :  "i")
				}
			}
			Set s_locations {
				Text: "Set of locations.";
				Index: i_loc1;
			}
			Set s_chargers {
				Index: i_charger;
				Definition: {
					ElementRange(
						From    :  1, 
						To      :  p_maxNumberChargersPerStation)
				}
			}
			Index i_loc {
				Range: s_locations;
				dex::ColumnName: Location;
			}
			Parameter p_longitude {
				IndexDomain: i_loc;
				dex::ColumnName: Longitude;
				dex::Dataset: DefaultData;
				dex::TableName: Locations;
			}
			Parameter p_latitude {
				IndexDomain: i_loc;
				dex::ColumnName: Latitude;
				dex::Dataset: DefaultData;
				dex::TableName: Locations;
			}
		}
		DeclarationSection Control_Panel {
			Parameter p_maintenanceCost {
				InitialData: 500;
			}
			Parameter p_constructionCost {
				InitialData: 5000;
			}
			Parameter p_drivingCostPerMile {
				InitialData: 0.2;
			}
			Parameter p_chargingCostPerHour {
				InitialData: 0.5;
			}
			Parameter p_noAllocationPenalty {
				InitialData: 5000;
			}
			Parameter p_maxNumberChargersPerStation {
				InitialData: 8;
			}
			Parameter p_meanVehicleRange;
			Parameter p_maxVehicleRange {
				InitialData: 250;
			}
			Parameter p_chargingProbability;
			Parameter p_numberParticles {
				Text: "The number of particles in each individual.";
				Range: integer;
				InitialData: 400;
			}
			Parameter p_numberGenerations {
				InitialData: 50;
			}
			Parameter p_populationSize {
				Text: "Number of individuals in the population.";
				Range: integer;
				InitialData: 50;
			}
			Parameter p_inertiaComponent {
				InitialData: 0.83;
			}
			Parameter p_cognitiveComponent {
				InitialData: 0.05;
			}
			Parameter p_socialComponent {
				InitialData: 0.14;
			}
			Parameter p_initial_velocity {
				InitialData: 5;
			}
			Parameter p_spawn_region {
				Text: "Region in which particles each particle is spawned in an individual.";
				InitialData: 0.09;
				Comment: "Distance from an initial \'spawn\' location within which a particle can be initialized.";
			}
		}
	}
	Section PSO_Model {
		Comment: "This section contains procedures that align with the main operations within PSO.";
		DeclarationSection KNN_Declaration {
			Set s_def_nClosests {
				SubsetOf: Integers;
				Index: i_n_clos;
				Definition: ElementRange(1, p_def_nClosest, 1);
			}
			Parameter p_def_nClosest {
				Range: integer;
				InitialData: 20;
			}
			Parameter p_def_distanceCutoff {
				InitialData: 50;
			}
			ElementParameter ep_nClosestLocation {
				IndexDomain: (i_loc,i_indv);
				Range: s_def_particles;
			}
			ElementParameter ep_globalBestAllocations {
				IndexDomain: (i_loc,i_indv);
				Range: s_def_particles;
			}
			Parameter p_distances {
				IndexDomain: (i_particle,i_loc,i_indv);
			}
			Parameter p_allocationCount {
				IndexDomain: (i_particle,i_indv);
			}
			Parameter bp_def_activeStation {
				IndexDomain: (i_particle,i_indv);
				Definition: 1 $ p_allocationCount(i_particle,i_indv);
			}
			Parameter bp_def_unallocatedLocations {
				IndexDomain: (i_loc,i_indv);
				Range: binary;
				Definition: 1 $ (not ep_nClosestLocation(i_loc,i_indv));
			}
		}
		Parameter p_initialParticleLocationsX {
			IndexDomain: i_particle;
			Text: "Region in which to spawn each particle for each individual.";
		}
		Parameter p_initialParticleLocationsY {
			IndexDomain: i_particle;
			Text: "Region in which to spawn each particle for each individual.";
		}
		Parameter p_bestGlobalSolutionX {
			IndexDomain: (i_particle);
			Text: "Best global solution X coordinate.";
		}
		Parameter p_bestGlobalSolutionY {
			IndexDomain: (i_particle);
			Text: "Best global solution Y coordinate.";
		}
		Parameter p_currentSolutionX {
			IndexDomain: (i_indv,i_particle);
			Text: "X coordinates of the current solution for the individual.";
		}
		Parameter p_currentSolutionY {
			IndexDomain: (i_indv,i_particle);
			Text: "Y coordinates of the current solution for the individual.";
		}
		Parameter p_bestLocalSolutionX {
			IndexDomain: (i_indv,i_particle);
			Text: "Best local solution X coordinate.";
		}
		Parameter p_bestLocalSolutionY {
			IndexDomain: (i_indv,i_particle);
			Text: "Best local solution Y coordinate.";
		}
		Parameter p_previousSolutionX {
			IndexDomain: (i_indv,i_particle);
			Text: "X coordinates of the previous solution for the individual.";
		}
		Parameter p_previousSolutionY {
			IndexDomain: (i_indv,i_particle);
			Text: "Y coordinates of the previous solution for the individual.";
		}
		Parameter p_currentSolutionVelocityX {
			IndexDomain: (i_indv,i_particle);
			Text: "X velocity of the current solution for the individual.";
		}
		Parameter p_currentSolutionVelocityY {
			IndexDomain: (i_indv,i_particle);
			Text: "Y velocity of the current solution for the individual.";
		}
		Parameter p_previousSolutionVelocityX {
			IndexDomain: (i_indv,i_particle);
			Text: "X velocity of the previous solution for the individual.";
		}
		Parameter p_previousSolutionVelocityY {
			IndexDomain: (i_indv,i_particle);
			Text: "Y velocity of the previous solution for the individual.";
		}
		Parameter p_bestGlobalSolutionCost {
			Default: 999999999;
		}
		ElementParameter p_bestGlobalAllocation {
			IndexDomain: i_loc;
			Range: s_def_particles;
		}
		Parameter p_bestGlobalSolutionHappinessScore;
		Parameter p_bestGlobalSolutionMaintenanceCost {
			IndexDomain: i_particle;
		}
		Parameter p_bestGlobalSolutionConstructionCost {
			IndexDomain: i_particle;
		}
		Parameter p_bestGlobalSolutionDrivingCost {
			IndexDomain: i_particle;
		}
		Parameter p_bestGlobalSolutionChargerCost {
			IndexDomain: i_particle;
		}
		Parameter p_bestGlobalSolutionTotalCost {
			IndexDomain: i_particle;
		}
		Parameter p_bestGlobalSolutionNumberOfVehicles {
			IndexDomain: i_particle;
		}
		Parameter p_bestGlobalSolutionNumberOfChargers {
			IndexDomain: i_particle;
		}
		Parameter p_bestGlobalSolutionDistanceToStation {
			IndexDomain: i_loc;
		}
		Parameter p_bestLocalSolutionCost {
			IndexDomain: (i_indv);
			Default: inf;
		}
		Parameter p_totalConstructionCost {
			IndexDomain: i_indv;
		}
		Parameter p_totalMaintenanceCost {
			IndexDomain: i_indv;
		}
		Parameter p_totalDrivingCost {
			IndexDomain: (i_indv);
		}
		Parameter p_totalChargingCost {
			IndexDomain: (i_indv);
		}
		Parameter p_totalPenaltyCost {
			IndexDomain: i_indv;
		}
		Parameter p_totalObjectiveCost {
			IndexDomain: i_indv;
		}
		Parameter p_def_drivingCost {
			IndexDomain: (i_loc,i_indv);
			Definition: p_drivingCostPerMile * p_distances(ep_nClosestLocation(i_loc ,i_indv), i_loc, i_indv);
		}
		Parameter p_def_chargingCost {
			IndexDomain: (i_loc,i_indv);
			Definition: p_chargingCostPerHour;
			Comment: "This cost could change over time, so a formula can be inserted here.";
		}
		Procedure pr_initializeProblem {
			Body: {
				block ! Spawn Individuals 
				
				!@TODO Think if this will work for any latitude/longitude
				p_loc_xMin := min(i_loc, p_longitude(i_loc));
				p_loc_yMin := min(i_loc, p_latitude(i_loc));
				p_loc_xMax := max(i_loc, p_longitude(i_loc));
				p_loc_yMax := max(i_loc, p_latitude(i_loc));
				
				! Starting locations for the particles
				p_initialParticleLocationsX(i_particle) := Uniform(p_loc_xMin, p_loc_xMax);
				p_initialParticleLocationsY(i_particle) := Uniform(p_loc_yMin, p_loc_yMax);
				
				! Starting locations for the particles in each individual
				p_currentSolutionX(i_indv, i_particle) 
				:=  p_initialParticleLocationsX(i_particle) 
				    + Uniform(-p_spawn_region, p_spawn_region);
				
				p_currentSolutionY(i_indv, i_particle) 
				:=  p_initialParticleLocationsY(i_particle) 
				    + Uniform(-p_spawn_region, p_spawn_region);
				
				! Starting velocities
				p_loc_binomial(i_indv,i_particle) := Binomial(0.5, 1);
				p_currentSolutionVelocityX(i_indv, i_particle) := (-1 + 2 * p_loc_binomial(i_indv,i_particle)) * Normal(p_initial_velocity, p_initial_velocity/2);
				p_currentSolutionVelocityY(i_indv, i_particle) := (-1 + 2 * p_loc_binomial(i_indv,i_particle)) * Normal(p_initial_velocity, p_initial_velocity/2);
				
				endblock;
				
				block ! Initiate Cognitive Component 
				
				! Set the best local solution as something close to the initial solution
				p_bestLocalSolutionX(i_indv,i_particle) 
				:=  p_currentSolutionX(i_indv,i_particle) 
				    + Uniform(-p_spawn_region/2, p_spawn_region/2);
				
				p_bestLocalSolutionY(i_indv,i_particle) 
				:=  p_currentSolutionY(i_indv,i_particle) 
				    + Uniform(-p_spawn_region/2, p_spawn_region/2);
				
				endblock;
				
				block ! Initiate Social Component 
				
				! Select random individual as the initial best global
				ep_individual := StringToElement(s_def_individuals, FormatString("i%n", round(uniform(0, p_populationSize))));
				
				! Set the best local solution as something close to the initial solution
				p_bestGlobalSolutionX(i_particle) := p_currentSolutionX(ep_individual, i_particle);
				p_bestGlobalSolutionY(i_particle) := p_currentSolutionY(ep_individual, i_particle);
				
				endblock;
				
				p_bestLocalSolutionCost(i_indv) := inf;
				p_bestGlobalSolutionCost := inf;
			}
			Parameter p_loc_xMin {
				Text: "Lowerbound for x-domain.";
			}
			Parameter p_loc_xMax {
				Text: "Upperbound for x-domain.";
			}
			Parameter p_loc_yMin {
				Text: "Lowerbound for y-domain.";
			}
			Parameter p_loc_yMax {
				Text: "Upperbound for y-domain.";
			}
			Parameter p_loc_binomial {
				IndexDomain: (i_indv,i_particle);
			}
		}
		Procedure pr_KNNSubroutine {
			Body: {
				block ! Calculate Distances
				
				!@TODO: maybe we can change this to haversine? For a basic model I think this is fine, it depends on the size of the region though. It could be useful to give the user an option.
				for (i_indv in s_def_individuals) do
				
					! Calculate the Euclidean distance between each particle and each location
					p_distances(i_particle,i_loc,i_indv) 
					:=  sqrt(
				            (p_currentSolutionX(i_indv,i_particle) - p_longitude(i_loc))^2 
					        + (p_currentSolutionY(i_indv,i_particle) - p_latitude(i_loc))^2);
				
				endfor;
				
				endblock;
				
				pr_getClosest;
			}
		}
		Procedure pr_getClosest {
			Body: {
				p_loc_distances(i_particle,i_loc,i_indv) 
				:=  p_distances(i_particle,i_loc,i_indv) $ (p_distances(i_particle,i_loc,i_indv) < p_def_distanceCutoff);
				
				empty p_allocationCount;
				empty ep_nClosestLocation;
				
				for (i_indv in s_def_individuals) do
				
					for (i_loc in s_locations) do
				
						empty ep_loc_particle;
						p_loc_break := 0;
				
						! Find the nearest N locations
						for i_n_clos in {1 .. p_def_nClosest} do
				
							! Now, if we manage an allocation then stop looking for the next N closest
							ep_loc_particle(i_loc,i_n_clos,i_indv) := argmin(i_particle | p_loc_distances(i_particle,i_loc,i_indv) and (0.35 * p_allocationCount(i_particle,i_indv) < 2 * p_maxNumberChargersPerStation), p_loc_distances(i_particle,i_loc,i_indv));
							ep_nClosestLocation(i_loc,i_indv) := ep_loc_particle(i_loc,i_n_clos,i_indv);
							p_allocationCount(ep_loc_particle(i_loc,i_n_clos,i_indv),i_indv) += 1;
							p_loc_distances(ep_loc_particle(i_loc,i_n_clos,i_indv),i_loc,i_indv) := 0;
				
							if ep_loc_particle(i_loc,i_n_clos,i_indv) then
								p_loc_break := 1;
								break;
							endif;
				
						endfor;
					endfor;
				endfor;
			}
			Comment: "Determine the N closest locations for each vehicle";
			Parameter p_loc_break {
				Default: 0;
			}
			Parameter p_loc_distances {
				IndexDomain: (i_particle,i_loc,i_indv);
			}
			ElementParameter ep_loc_particle {
				IndexDomain: (i_loc,i_n_clos,i_indv);
				Range: s_def_particles;
			}
		}
		Procedure pr_evaluateCost {
			Body: {
				! Total costs
				block
				p_totalConstructionCost(i_indv) 
				:=  p_constructionCost * sum(i_particle, bp_def_activeStation(i_particle, i_indv));
				
				p_totalMaintenanceCost(i_indv) 
				:=  p_maintenanceCost 
				    * sum(i_particle, bp_def_activeStation(i_particle, i_indv));
				
				p_totalDrivingCost(i_indv) 
				:=  sum(i_loc, p_def_drivingCost(i_loc, i_indv));
				
				p_totalChargingCost(i_indv) 
				:=  sum(i_loc, p_def_chargingCost(i_loc, i_indv));
				
				p_totalPenaltyCost(i_indv) 
				:=  p_noAllocationPenalty 
				    * sum(i_loc, bp_def_unallocatedLocations(i_loc, i_indv));
				
				p_totalObjectiveCost(i_indv) 
				:= 	p_totalDrivingCost(i_indv)
					+ p_totalChargingCost(i_indv)
					+ p_totalConstructionCost(i_indv)
					+ p_totalMaintenanceCost(i_indv)
					+ p_totalPenaltyCost(i_indv);
				endblock;
			}
		}
		Procedure pr_updateVariations {
			Body: {
				block ! Apply the velocity update 
				p_previousSolutionVelocityX(i_indv,i_particle) := p_currentSolutionVelocityX(i_indv,i_particle);
				p_previousSolutionVelocityY(i_indv,i_particle) := p_currentSolutionVelocityY(i_indv,i_particle);
				p_previousSolutionX(i_indv,i_particle) := p_currentSolutionX(i_indv,i_particle);
				p_previousSolutionY(i_indv,i_particle) := p_currentSolutionY(i_indv,i_particle);
				
				p_loc_inertiaX(i_indv,i_particle) := p_inertiaComponent * p_previousSolutionVelocityX(i_indv,i_particle);
				p_loc_inertiaY(i_indv,i_particle) := p_inertiaComponent * p_previousSolutionVelocityY(i_indv,i_particle);
				
				p_loc_cognitiveX(i_indv,i_particle) := p_cognitiveComponent * (p_bestLocalSolutionX(i_indv,i_particle) - p_previousSolutionX(i_indv,i_particle));
				p_loc_cognitiveY(i_indv,i_particle) := p_cognitiveComponent * (p_bestLocalSolutionY(i_indv,i_particle) - p_previousSolutionY(i_indv,i_particle));
				
				p_loc_socialX(i_indv,i_particle) := p_socialComponent * (p_bestGlobalSolutionX(i_particle) - p_previousSolutionX(i_indv,i_particle));
				p_loc_socialY(i_indv,i_particle) := p_socialComponent * (p_bestGlobalSolutionY(i_particle) - p_previousSolutionY(i_indv,i_particle));
				
				p_currentSolutionVelocityX(i_indv,i_particle) 
				:=  p_loc_inertiaX(i_indv,i_particle) 
				    + p_loc_cognitiveX(i_indv,i_particle) 
				    + p_loc_socialX(i_indv,i_particle);
				
				p_currentSolutionVelocityY(i_indv,i_particle) 
				:=  p_loc_inertiaY(i_indv,i_particle) 
				    + p_loc_cognitiveY(i_indv,i_particle) 
				    + p_loc_socialY(i_indv,i_particle);
				
				endblock;
				
				block ! Apply the position update 
				p_currentSolutionX(i_indv,i_particle) := p_previousSolutionX(i_indv,i_particle) + p_currentSolutionVelocityX(i_indv,i_particle);
				p_currentSolutionY(i_indv,i_particle) := p_previousSolutionY(i_indv,i_particle) + p_currentSolutionVelocityY(i_indv,i_particle);
				endblock;
				
				block ! Find the global best 
				ep_loc_globalBest := argmin(i_indv, p_totalObjectiveCost(i_indv));
				
				if p_totalObjectiveCost(ep_loc_globalBest) < p_bestGlobalSolutionCost then
				
					p_bestGlobalAllocation(i_loc) := ep_nClosestLocation(i_loc, ep_loc_globalBest);
				
					p_bestGlobalSolutionCost := p_totalObjectiveCost(ep_loc_globalBest);
				
					! Store the global best locations
					p_bestGlobalSolutionX(i_particle) := p_currentSolutionX(ep_loc_globalBest,i_particle);
					p_bestGlobalSolutionY(i_particle) := p_currentSolutionY(ep_loc_globalBest,i_particle);
				
					! Store the global best KPIs
					p_bestGlobalSolutionHappinessScore := 1 - sum(i_loc, bp_def_unallocatedLocations(i_loc,ep_loc_globalBest)) /$ card(i_loc);
					p_bestGlobalSolutionMaintenanceCost(i_particle) := p_maintenanceCost * bp_def_activeStation(i_particle, ep_loc_globalBest);
					p_bestGlobalSolutionConstructionCost(i_particle) := p_constructionCost * bp_def_activeStation(i_particle, ep_loc_globalBest);
					p_bestGlobalSolutionDrivingCost(i_particle) := sum(i_loc | p_bestGlobalAllocation(i_loc) = i_particle, p_def_drivingCost(i_loc, ep_loc_globalBest));
					p_bestGlobalSolutionChargerCost(i_particle) := sum(i_loc | p_bestGlobalAllocation(i_loc) = i_particle, p_def_chargingCost(i_loc, ep_loc_globalBest));
					p_bestGlobalSolutionNumberOfVehicles(i_particle) := p_allocationCount(i_particle, ep_loc_globalBest);
					p_bestGlobalSolutionTotalCost(i_particle) := p_bestGlobalSolutionMaintenanceCost(i_particle)
																	+ p_bestGlobalSolutionConstructionCost(i_particle)
																	+ p_bestGlobalSolutionDrivingCost(i_particle)
																	+ p_bestGlobalSolutionChargerCost(i_particle);
				
					p_bestGlobalSolutionDistanceToStation(i_loc) := p_distances(ep_nClosestLocation(i_loc,ep_loc_globalBest), i_loc, ep_loc_globalBest);
				
				endif;
				endblock;
				
				block ! Find the local best 
				
				for i_indv | (p_totalObjectiveCost(i_indv) < p_bestLocalSolutionCost(i_indv)) do 
				
					p_bestLocalSolutionCost(i_indv) := p_totalObjectiveCost(i_indv);
				
					p_bestLocalSolutionX(i_indv,i_particle) := p_currentSolutionX(i_indv,i_particle);
					p_bestLocalSolutionY(i_indv,i_particle) := p_currentSolutionY(i_indv,i_particle);
				
				endfor;
				endblock;
			}
			Parameter p_loc_inertiaX {
				IndexDomain: (i_indv,i_particle);
			}
			Parameter p_loc_inertiaY {
				IndexDomain: (i_indv,i_particle);
			}
			Parameter p_loc_cognitiveX {
				IndexDomain: (i_indv,i_particle);
			}
			Parameter p_loc_cognitiveY {
				IndexDomain: (i_indv,i_particle);
			}
			Parameter p_loc_socialX {
				IndexDomain: (i_indv,i_particle);
			}
			Parameter p_loc_socialY {
				IndexDomain: (i_indv,i_particle);
			}
			ElementParameter ep_loc_globalBest {
				Range: s_def_individuals;
			}
		}
		Procedure pr_runPSOAlgorithm {
			Body: {
				pr_initializeProblem;
				
				for (i_gen in s_def_generations) do
				
					pr_KNNSubroutine;
					pr_evaluateCost;
					pr_updateVariations;
				
					p_generationalFitness(i_gen) := mean(i_indv, p_totalObjectiveCost(i_indv));
					p_globalBestFitness(i_gen) := p_bestGlobalSolutionCost;
				
				endfor;
				
				! Number of chargers per station
				for i_charger in s_chargers do
					p_chargersPerStation_hist(i_charger) := sum[i_particle | p_bestGlobalSolutionNumberOfVehicles(i_particle) = Val(i_charger), 1 $ p_bestGlobalSolutionNumberOfVehicles(i_particle)];
				endfor;
			}
		}
		Procedure pr_resetPSO {
			Body: {
				empty PSO_Model;
			}
		}
		DeclarationSection Final_Results {
			Parameter p_generationalFitness {
				IndexDomain: i_gen;
			}
			Parameter p_globalBestFitness {
				IndexDomain: i_gen;
			}
			Parameter p_chargersPerStation_hist {
				IndexDomain: (i_charger);
			}
		}
	}
	Section MIP_Model {
		Comment: "Section to record and wrangle different results for display on the UI.";
		Procedure Solve_MIP {
			Body: {
				solve MIP_Assignment;
			}
		}
		DeclarationSection MIP_Declaration {
			Parameter Distances_domain {
				IndexDomain: (i_particle,i_loc,i_indv);
				Definition: p_distances(i_particle,i_loc,i_indv) <= 30;
			}
			Variable Vehicle_to_Station {
				IndexDomain: (i_particle,i_loc,i_indv);
				Range: binary;
			}
			Variable Max_Vehicles_Violation {
				IndexDomain: (i_loc,i_indv);
				Range: nonnegative;
			}
			Constraint Assign_Vehicle_to_Station {
				IndexDomain: (i_particle,i_indv) | exists[i_loc, Distances_domain(i_particle,i_loc,i_indv)];
				Definition: sum[ i_loc, Vehicle_to_Station(i_particle,i_loc,i_indv)] = 1;
			}
			Constraint Restrict_Max_Vehicles {
				IndexDomain: (i_loc,i_indv);
				Definition: sum[ i_particle, Vehicle_to_Station(i_particle,i_loc,i_indv)] <= 16 + Max_Vehicles_Violation(i_loc,i_indv);
			}
			Variable TotalDistance {
				Range: free;
				Definition: sum[ (i_particle,i_loc,i_indv) | Distances_domain(i_particle,i_loc,i_indv), Vehicle_to_Station(i_particle,i_loc,i_indv) * p_distances(i_particle,i_loc,i_indv)];
			}
			Variable TotalPenalty {
				Range: free;
				Definition: sum[ (i_loc,i_indv), Max_Vehicles_Violation(i_loc,i_indv)] * 1000;
			}
			Variable TotalCost {
				Range: free;
				Definition: {
					TotalDistance
					+ TotalPenalty
				}
			}
			MathematicalProgram MIP_Assignment {
				Objective: TotalCost;
				Direction: minimize;
				Constraints: AllConstraints;
				Variables: AllVariables;
				Type: Automatic;
			}
		}
		DeclarationSection MIP_Assignments {
			Parameter Vehicle_to_Station_Distances {
				IndexDomain: (i_particle,i_loc,i_indv);
				Definition: Vehicle_to_Station(i_particle,i_loc,i_indv) * p_distances(i_particle,i_loc,i_indv);
			}
		}
	}
	Procedure MainInitialization {
		Body: {
			!dex::GenerateDatasetMappings;
			dex::ReadAllMappings;
			
			! Read load data
			dex::ReadFromFile("DefaultData.xlsx", "Generated/DefaultData-Excel");
		}
		Comment: "Add initialization statements here that do NOT require any library being initialized already.";
	}
	Procedure PostMainInitialization {
		Comment: {
			"Add initialization statements here that require that the libraries are already initialized properly,
			or add statements that require the Data Management module to be initialized."
		}
	}
	Procedure MainExecution;
	Procedure PreMainTermination {
		Body: {
			return DataManagementExit();
		}
		Comment: {
			"Add termination statements here that require all libraries to be still alive.
			Return 1 if you allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence."
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require all libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
}
